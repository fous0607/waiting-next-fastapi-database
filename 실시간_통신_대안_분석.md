# 실시간 통신 대안 상세 분석

현재 시스템은 **5초 Polling (SWR)** 방식을 사용하고 있습니다.
더 나은 실시간성을 위한 3가지 대안을 상세히 분석합니다.

---

## 대안 1: Vercel Edge Functions + Durable Objects

### 개요
Vercel의 차세대 기술로, Edge에서 **상태를 유지**할 수 있는 기능입니다.
Cloudflare의 Durable Objects와 유사한 개념입니다.

### 기술 상세

#### 작동 원리
```
┌─────────────┐
│  Client 1   │──┐
└─────────────┘  │
                 ├──→ ┌──────────────────┐
┌─────────────┐  │    │ Durable Object   │ (상태 유지)
│  Client 2   │──┤    │ (Edge Runtime)   │
└─────────────┘  │    └──────────────────┘
                 │              │
┌─────────────┐  │              ↓
│  Client 3   │──┘    ┌──────────────────┐
└─────────────┘       │   PostgreSQL     │
                      └──────────────────┘
```

- **Edge Runtime**: 전 세계 CDN 노드에서 실행
- **Durable Object**: 특정 "객체"가 하나의 인스턴스만 존재 (싱글톤)
- **WebSocket 지원**: 진짜 양방향 실시간 통신

#### 코드 예시
```typescript
// edge-function/waiting-room.ts
export class WaitingRoom {
  private connections: Set<WebSocket> = new Set();
  
  async fetch(request: Request) {
    const { 0: client, 1: server } = new WebSocketPair();
    
    this.connections.add(server);
    
    server.addEventListener('close', () => {
      this.connections.delete(server);
    });
    
    return new Response(null, { status: 101, webSocket: client });
  }
  
  broadcast(message: any) {
    for (const ws of this.connections) {
      ws.send(JSON.stringify(message));
    }
  }
}
```

### 장점
- ✅ **진짜 실시간**: 밀리초 단위 업데이트
- ✅ **낮은 지연**: Edge에서 실행 (사용자와 가까움)
- ✅ **효율적**: 이벤트 발생 시에만 전송
- ✅ **Vercel 네이티브**: 추가 서비스 불필요

### 단점
- ❌ **아직 베타**: 프로덕션 사용 위험
- ❌ **문서 부족**: 레퍼런스 적음
- ❌ **제한적**: 일부 기능만 지원
- ❌ **비용 불명확**: 정식 출시 후 가격 책정 예상

### 비용 (예상)
```
현재 베타 단계로 무료
정식 출시 시 예상:
- 기본: $20/월
- 연결 시간: $0.02 / 1M 연결-초
- 요청: $0.60 / 1M 요청

예상 월 비용 (매장 10개):
- 연결 시간: 10 매장 × 5 클라이언트 × 10시간 × 30일 × 3600초 = 54M 연결-초
  → $0.02 × 54 = $1.08
- 요청: 무시할 수준
- 총: ~$21/월
```

### 구현 복잡도
- **난이도**: ⭐⭐⭐⭐ (높음)
- **개발 시간**: 2-3주
- **유지보수**: 중간

### 추천 여부
⚠️ **현재는 비추천**
- 베타 단계로 안정성 보장 안 됨
- 1년 후 정식 출시 시 재검토 권장

---

## 대안 2: 외부 WebSocket 서비스 (Pusher, Ably)

### 개요
전문 실시간 통신 서비스를 사용하는 방식입니다.
가장 **검증되고 안정적인** 방법입니다.

### 주요 서비스 비교

#### 2-1. Pusher Channels

**특징:**
- 가장 대중적 (Uber, GitHub 사용)
- 간단한 API
- 한국 리전 없음 (싱가포르 사용)

**가격:**
```
Free Tier:
- 100 동시 접속
- 200,000 메시지/일
- 무료

Standard Plan: $49/월
- 500 동시 접속
- 무제한 메시지
- 이메일 지원

Pro Plan: $299/월
- 2,000 동시 접속
- 무제한 메시지
- 24/7 지원
```

**코드 예시:**
```typescript
// Backend (FastAPI)
import pusher

pusher_client = pusher.Pusher(
  app_id='your-app-id',
  key='your-key',
  secret='your-secret',
  cluster='ap1',  # 싱가포르
  ssl=True
)

@router.post("/waiting/register")
async def register_waiting(data: WaitingCreate):
    # ... 대기 등록 로직 ...
    
    # Pusher로 실시간 전송
    pusher_client.trigger(
        f'store-{store_id}',
        'new-waiting',
        {'data': waiting_data}
    )
    
    return waiting_data
```

```typescript
// Frontend (Next.js)
import Pusher from 'pusher-js';

const pusher = new Pusher('your-key', {
  cluster: 'ap1'
});

const channel = pusher.subscribe(`store-${storeId}`);

channel.bind('new-waiting', (data) => {
  // 실시간 업데이트
  setWaitingList(prev => [...prev, data]);
});
```

**장점:**
- ✅ **매우 안정적**: 99.999% 업타임
- ✅ **간단한 구현**: 1-2일이면 완성
- ✅ **풍부한 문서**: 예제 많음
- ✅ **대시보드**: 실시간 모니터링

**단점:**
- ❌ **비용**: 매장 늘어나면 비용 증가
- ❌ **한국 리전 없음**: 약간의 지연 (50-100ms)
- ❌ **종속성**: 서비스 장애 시 영향

---

#### 2-2. Ably

**특징:**
- Pusher보다 저렴
- 더 많은 기능 (메시지 히스토리, 자동 재연결 등)
- 한국 리전 없음

**가격:**
```
Free Tier:
- 200 동시 접속
- 6M 메시지/월
- 무료

Standard Plan: $29/월
- 500 동시 접속
- 50M 메시지/월
- 이메일 지원

Pro Plan: $299/월
- 2,000 동시 접속
- 200M 메시지/월
- 24/7 지원
```

**코드 예시:**
```typescript
// Backend
from ably import AblyRest

ably = AblyRest('your-api-key')
channel = ably.channels.get(f'store-{store_id}')

channel.publish('new-waiting', waiting_data)
```

```typescript
// Frontend
import Ably from 'ably';

const ably = new Ably.Realtime('your-api-key');
const channel = ably.channels.get(`store-${storeId}`);

channel.subscribe('new-waiting', (message) => {
  setWaitingList(prev => [...prev, message.data]);
});
```

**장점:**
- ✅ **Pusher보다 저렴**: 40% 정도 저렴
- ✅ **더 많은 기능**: 메시지 히스토리, Presence 등
- ✅ **자동 재연결**: 네트워크 끊김 시 자동 복구

**단점:**
- ❌ **Pusher보다 덜 유명**: 레퍼런스 적음
- ❌ **한국 리전 없음**: 지연 존재

---

#### 2-3. 비용 시뮬레이션 (귀하의 경우)

**가정:**
- 매장 10개
- 각 매장: 관리자 2명 + 현황판 1개 + 접수대 1개 = 5 클라이언트
- 총 동시 접속: 50명
- 운영 시간: 하루 10시간

**Pusher:**
```
Free Tier: 100 동시 접속 → 충분! (50명)
메시지: 대기 등록 1회당 5개 메시지 (관리자×2, 현황판, 접수대, 모니터)
       하루 100명 등록 × 5 메시지 × 10 매장 = 5,000 메시지/일
       월간: 150,000 메시지 → Free Tier 범위 내!

결론: 무료로 사용 가능!
```

**Ably:**
```
Free Tier: 200 동시 접속 → 충분!
메시지: 150,000 메시지/월 → Free Tier 범위 내!

결론: 무료로 사용 가능!
```

**매장 50개로 확장 시:**
```
동시 접속: 250명
Pusher: Standard Plan ($49/월) 필요
Ably: Standard Plan ($29/월) 필요
```

---

### 구현 가이드 (Pusher 기준)

#### Step 1: Pusher 가입 및 설정
```bash
# 1. https://pusher.com 가입
# 2. 새 앱 생성 (Cluster: ap1 - 싱가포르)
# 3. Credentials 복사
```

#### Step 2: Backend 설정
```bash
cd backend
pip install pusher
```

```python
# backend/core/pusher_client.py
import os
from pusher import Pusher

pusher_client = Pusher(
    app_id=os.getenv('PUSHER_APP_ID'),
    key=os.getenv('PUSHER_KEY'),
    secret=os.getenv('PUSHER_SECRET'),
    cluster=os.getenv('PUSHER_CLUSTER', 'ap1'),
    ssl=True
)

def broadcast_to_store(store_id: str, event: str, data: dict):
    """매장에 실시간 메시지 전송"""
    pusher_client.trigger(
        f'store-{store_id}',
        event,
        data
    )
```

```python
# backend/routers/waiting_board.py 수정
from core.pusher_client import broadcast_to_store

@router.post("/register")
async def register_waiting(...):
    # ... 기존 로직 ...
    
    # Pusher로 실시간 전송
    broadcast_to_store(
        store_id=str(current_store.id),
        event='new_waiting',
        data={
            'id': new_waiting.id,
            'name': new_waiting.name,
            'class_name': class_info.class_name,
            # ... 필요한 데이터
        }
    )
    
    return new_waiting
```

#### Step 3: Frontend 설정
```bash
cd frontend
npm install pusher-js
```

```typescript
// frontend/hooks/usePusher.ts
import { useEffect } from 'react';
import Pusher from 'pusher-js';
import { useWaitingStore } from '@/lib/store/useWaitingStore';

export function usePusher() {
  const { selectedStoreId, refreshAll } = useWaitingStore();
  
  useEffect(() => {
    if (!selectedStoreId) return;
    
    const pusher = new Pusher(process.env.NEXT_PUBLIC_PUSHER_KEY!, {
      cluster: 'ap1'
    });
    
    const channel = pusher.subscribe(`store-${selectedStoreId}`);
    
    // 이벤트 리스너
    channel.bind('new_waiting', () => refreshAll());
    channel.bind('status_changed', () => refreshAll());
    channel.bind('order_changed', () => refreshAll());
    
    return () => {
      channel.unbind_all();
      channel.unsubscribe();
      pusher.disconnect();
    };
  }, [selectedStoreId, refreshAll]);
}
```

```typescript
// frontend/app/manage/page.tsx
import { usePusher } from '@/hooks/usePusher';

function ManageContent() {
  usePusher(); // Pusher 연결
  
  // ... 기존 코드 ...
}
```

#### Step 4: 환경 변수 설정
```bash
# backend/.env
PUSHER_APP_ID=your-app-id
PUSHER_KEY=your-key
PUSHER_SECRET=your-secret
PUSHER_CLUSTER=ap1

# frontend/.env.local
NEXT_PUBLIC_PUSHER_KEY=your-key
```

#### 구현 시간
- **Backend 수정**: 2-3시간
- **Frontend 수정**: 2-3시간
- **테스트**: 1-2시간
- **총**: 1일

---

## 대안 3: Redis Pub/Sub (Upstash)

### 개요
Redis의 Pub/Sub 기능을 사용하여 Serverless 환경에서 실시간 통신을 구현합니다.
**가장 저렴하고 유연한** 방법입니다.

### Upstash Redis 소개

**특징:**
- Serverless에 최적화된 Redis
- 사용한 만큼만 과금 (Pay-as-you-go)
- 글로벌 복제 지원
- **한국 리전 있음!** (ap-northeast-2)

**가격:**
```
Free Tier:
- 10,000 명령/일
- 256MB 스토리지
- 무료

Pay-as-you-go:
- $0.2 / 100K 명령
- $0.25 / GB 스토리지

예상 비용 (매장 10개):
- 명령: 대기 등록 1회당 10개 명령 (pub + 클라이언트 수)
        하루 100명 × 10 명령 × 10 매장 = 10,000 명령/일
        월간: 300,000 명령 → $0.6/월
- 스토리지: 거의 없음 (Pub/Sub은 저장 안 함)
- 총: ~$1/월
```

### 아키텍처

```
┌──────────────┐
│  Frontend 1  │──┐
└──────────────┘  │
                  ├──→ ┌─────────────────┐
┌──────────────┐  │    │ Vercel Function │
│  Frontend 2  │──┤    │   (Subscriber)  │
└──────────────┘  │    └─────────────────┘
                  │              ↓
┌──────────────┐  │    ┌─────────────────┐
│  Frontend 3  │──┘    │ Upstash Redis   │ (Pub/Sub)
└──────────────┘       │  (ap-northeast) │
                       └─────────────────┘
                                 ↑
                       ┌─────────────────┐
                       │ Vercel Function │
                       │   (Publisher)   │
                       └─────────────────┘
                                 ↑
                       ┌─────────────────┐
                       │  Backend API    │
                       └─────────────────┘
```

**작동 방식:**
1. Backend가 대기 등록 → Redis에 Publish
2. Frontend가 Vercel Function에 SSE 연결
3. Vercel Function이 Redis Subscribe → 메시지 받으면 Frontend에 전송

### 구현 상세

#### Step 1: Upstash 설정
```bash
# 1. https://upstash.com 가입
# 2. Redis 데이터베이스 생성 (Region: ap-northeast-2)
# 3. REST API URL 복사
```

#### Step 2: Backend 설정
```bash
cd backend
pip install upstash-redis
```

```python
# backend/core/redis_client.py
import os
from upstash_redis import Redis

redis_client = Redis(
    url=os.getenv('UPSTASH_REDIS_REST_URL'),
    token=os.getenv('UPSTASH_REDIS_REST_TOKEN')
)

def publish_event(store_id: str, event: str, data: dict):
    """Redis에 이벤트 발행"""
    channel = f'store:{store_id}'
    message = {
        'event': event,
        'data': data,
        'timestamp': datetime.now().isoformat()
    }
    
    redis_client.publish(channel, json.dumps(message))
```

```python
# backend/routers/waiting_board.py 수정
from core.redis_client import publish_event

@router.post("/register")
async def register_waiting(...):
    # ... 기존 로직 ...
    
    # Redis Pub/Sub으로 전송
    publish_event(
        store_id=str(current_store.id),
        event='new_waiting',
        data={
            'id': new_waiting.id,
            'name': new_waiting.name,
            # ... 필요한 데이터
        }
    )
    
    return new_waiting
```

#### Step 3: Vercel Function (SSE Proxy)
```typescript
// frontend/app/api/realtime/route.ts
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const storeId = searchParams.get('store_id');
  
  const stream = new ReadableStream({
    async start(controller) {
      const channel = `store:${storeId}`;
      
      // Redis Subscribe (polling 방식)
      const interval = setInterval(async () => {
        try {
          // Upstash는 직접 Subscribe 불가, 대신 List 사용
          const messages = await redis.lpop(`queue:${storeId}`, 10);
          
          if (messages) {
            for (const msg of messages) {
              const data = `data: ${JSON.stringify(msg)}\n\n`;
              controller.enqueue(new TextEncoder().encode(data));
            }
          }
        } catch (error) {
          console.error('Redis error:', error);
        }
      }, 1000); // 1초마다 체크
      
      // 클라이언트 연결 종료 시 정리
      request.signal.addEventListener('abort', () => {
        clearInterval(interval);
        controller.close();
      });
    }
  });
  
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

**⚠️ 중요한 제약:**
Upstash는 **HTTP 기반**이라 진짜 Pub/Sub이 아닙니다.
대신 **List를 Queue처럼 사용**해야 합니다.

#### 개선된 방식: Upstash Kafka 사용

Upstash는 **Kafka**도 제공하는데, 이게 더 적합합니다.

```typescript
// Upstash Kafka 사용
import { Kafka } from '@upstash/kafka';

const kafka = new Kafka({
  url: process.env.UPSTASH_KAFKA_REST_URL!,
  username: process.env.UPSTASH_KAFKA_REST_USERNAME!,
  password: process.env.UPSTASH_KAFKA_REST_PASSWORD!,
});

// Producer (Backend)
await kafka.producer().produce({
  topic: `store-${storeId}`,
  value: JSON.stringify(eventData),
});

// Consumer (Vercel Function)
const consumer = kafka.consumer();
const messages = await consumer.consume({
  consumerGroupId: 'waiting-system',
  instanceId: 'instance-1',
  topics: [`store-${storeId}`],
});
```

**Upstash Kafka 가격:**
```
Free Tier:
- 10,000 메시지/일
- 무료

Pay-as-you-go:
- $0.4 / 100K 메시지
- $2 / GB 스토리지

예상 비용 (매장 10개):
- 메시지: 300,000/월 → $1.2/월
- 총: ~$2/월
```

---

### 장점
- ✅ **가장 저렴**: $1-2/월
- ✅ **한국 리전**: 낮은 지연 (5-10ms)
- ✅ **유연성**: 직접 제어 가능
- ✅ **Serverless 호환**: Vercel과 완벽 호환

### 단점
- ❌ **구현 복잡**: 2-3주 소요
- ❌ **유지보수**: 직접 관리 필요
- ❌ **디버깅 어려움**: 문제 발생 시 해결 어려움
- ❌ **Upstash 제약**: 진짜 Pub/Sub 아님 (HTTP 기반)

### 구현 복잡도
- **난이도**: ⭐⭐⭐⭐⭐ (매우 높음)
- **개발 시간**: 2-3주
- **유지보수**: 높음

---

## 종합 비교표

| 항목 | Polling (현재) | Vercel Edge | Pusher | Ably | Upstash Redis/Kafka |
|------|---------------|-------------|--------|------|---------------------|
| **실시간성** | 5초 지연 | 즉시 | 즉시 | 즉시 | 1초 지연 |
| **안정성** | ★★★★★ | ★★☆☆☆ | ★★★★★ | ★★★★★ | ★★★★☆ |
| **비용 (10매장)** | 무료 | ~$21/월 | 무료 | 무료 | ~$2/월 |
| **비용 (50매장)** | 무료 | ~$50/월 | $49/월 | $29/월 | ~$5/월 |
| **한국 리전** | N/A | ✅ | ❌ | ❌ | ✅ |
| **구현 난이도** | ⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **개발 시간** | 완료 | 2-3주 | 1일 | 1일 | 2-3주 |
| **유지보수** | 쉬움 | 어려움 | 쉬움 | 쉬움 | 어려움 |
| **종속성** | 없음 | Vercel | Pusher | Ably | Upstash |
| **프로덕션 준비** | ✅ | ❌ (베타) | ✅ | ✅ | ✅ |

---

## 추천 로드맵

### 현재 단계 (매장 1-10개)
**✅ 5초 Polling 유지**
- 이유: 무료, 안정적, 충분한 성능
- 비용: $0
- 실시간성: 5초 지연 (허용 가능)

### 성장 단계 (매장 10-30개)
**→ Pusher 또는 Ably 도입**
- 이유: 검증된 서비스, 간단한 구현
- 비용: $0-49/월 (Pusher Free Tier → Standard)
- 실시간성: 즉시
- 마이그레이션: 1-2일

### 확장 단계 (매장 30-100개)
**→ Ably로 전환 (비용 절감)**
- 이유: Pusher보다 40% 저렴
- 비용: $29-299/월
- 실시간성: 즉시

### 대규모 단계 (매장 100개+)
**→ Upstash Kafka 또는 자체 구축**
- 이유: 비용 효율성, 완전한 제어
- 비용: ~$10-50/월
- 실시간성: 즉시
- 단, 개발 리소스 충분할 때만

---

## 결론 및 권장사항

### 즉시 적용 가능한 옵션
**1순위: Pusher (Free Tier)**
- ✅ 지금 당장 무료로 사용 가능
- ✅ 1일이면 구현 완료
- ✅ 매장 50개까지 무료
- ✅ 검증된 안정성

**구현 순서:**
1. Pusher 가입 (5분)
2. Backend 수정 (2시간)
3. Frontend 수정 (2시간)
4. 테스트 (1시간)
5. 배포 (10분)

**총 소요 시간: 1일**

### 장기적 관점
- **매장 10개 이하**: 현재 Polling 유지
- **매장 10-50개**: Pusher Free Tier
- **매장 50개 이상**: Ably Standard ($29/월)
- **매장 100개 이상**: 자체 구축 검토

### 최종 추천
**현재는 Polling 유지, 필요 시 Pusher로 1일 만에 전환**

이유:
1. 현재 시스템이 잘 작동하고 있음
2. Pusher는 언제든 1일 만에 적용 가능
3. 무료로 시작 가능
4. 필요할 때 빠르게 전환 가능

**Vercel Edge는 1년 후 재검토 권장**
